#!/usr/bin/env bash
#
# Updates docker-compose to the latest version available on the web
#
# from: https://gist.github.com/wdullaer/f1af16bd7e970389bad3
#
# Requires:
# - git
# - curl
# - already setup ~/apps/docker-compose and link

# ARG_OPTIONAL_SINGLE([dir],[d],[directory to install into])
# ARG_OPTIONAL_SINGLE([bin],[],[dir to link binary to - should be in the PATH])
# ARG_POSITIONAL_INF([commands],[commands to update])
# ARG_HELP([Updates commands to the latest version available on the web])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='dh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_commands=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_dir=
_arg_bin=

print_help ()
{
	printf '%s\n' "Updates commands to the latest version available on the web"
	printf 'Usage: %s [-d|--dir <arg>] [--bin <arg>] [-h|--help] [<commands-1>] ... [<commands-n>] ...\n' "$0"
	printf '\t%s\n' "<commands>: commands to update"
	printf '\t%s\n' "-d,--dir: directory to install into (no default)"
	printf '\t%s\n' "--bin: dir to link binary to - should be in the PATH (no default)"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--dir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_dir="$2"
				shift
				;;
			--dir=*)
				_arg_dir="${_key##--dir=}"
				;;
			-d*)
				_arg_dir="${_key##-d}"
				;;
			--bin)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_bin="$2"
				shift
				;;
			--bin=*)
				_arg_bin="${_key##--bin=}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


assign_positional_args ()
{
	_positional_names=()
	_our_args=$((${#_positionals[@]} - ${#_positional_names[@]}))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names+=("_arg_commands[$((ii + 0))]")
	done

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# mapping of commands to repos
declare -A repos
# mapping of commands to download filename patterns
# (please use single quotes to defer any interpretation)
declare -A releases
# mapping of options to get version number
declare -A versions

# each command needs an entry in the 3 arrays defined above

repos["docker-compose"]='https://github.com/docker/compose'
# little trick here, for version 0.12.2 tag is v0.12.2 (notice leading v)
releases["docker-compose"]='"${_REPO}/releases/download/${_VERSION}/${_CMD}-`uname -s`-`uname -m`"'
versions["docker-compose"]='--version'

repos["docker-machine"]='https://github.com/docker/machine'
# little trick here, for version 0.12.2 tag is v0.12.2 (notice leading v)
releases["docker-machine"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-`uname -s`-`uname -m`"'
versions["docker-machine"]='--version'

repos["kompose"]='https://github.com/kubernetes/kompose'
# kompose has 3 tweaks: 0.12.2 is v0.12.2, ends with amd64, and uname is lowercase only
releases["kompose"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-`uname -s | tr '[:upper:]' '[:lower:]'`-amd64"'
versions["kompose"]='version'

repos["minikube"]='https://github.com/kubernetes/minikube'
releases["minikube"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-`uname -s | tr '[:upper:]' '[:lower:]'`-amd64"'
versions["minikube"]='version'

repos["ctop"]='https://github.com/bcicen/ctop'
# https://github.com/bcicen/ctop/releases/download/v0.7.1/ctop-0.7.1-linux-amd64
releases["ctop"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-${_VERSION}-`uname -s | tr '[:upper:]' '[:lower:]'`-amd64"'
versions["ctop"]='-v'

ACTION_NOTHING='do nothing'
ACTION_INSTALL='install'
ACTION_UPDATE='update'

# decides which action to perform for the specified args: nothing, update, or install
# $1 is command to update (must be directly invokable, accept a --version option,
# and return a parseable version in its output)
# $2 is the repo to query
#
# sets
# - ACTION
# - TARGET_VERSION
decide_action() {
  CMD=$1
  REPO=$2
  TARGET_VERSION=$3
#  if [ "$CMD" == 'ctop' ]; then
#    echo "target is '$TARGET_VERSION'"
#    exit 99
#  fi
  # todo crash if missing an arg
  if [ -z "$TARGET_VERSION" ]; then
    # target version determination is complex: 1.10.0 is preferred to 1.9.1 in semver, but incorrectly sorted by a naive 'sort' function...
    # so we have to fetch all tags, then pad all their version elements to 3 digits, sort, keep 1, then de-pad
#    TARGET_VERSION=`git ls-remote $REPO | grep refs/tags | grep -oP "[0-9]+\.[0-9]+\.[0-9]+$" | tail -n 1`
    TARGET_VERSION=`git ls-remote $REPO | grep refs/tags | grep -oP "[0-9]+\.[0-9]+\.[0-9]+$" | sed -e 's/\b[0-9]\b/00&/g; s/\b[0-9]\{2\}\b/0&/g' | sort | tail -n 1 | sed -e 's/\b0*\([0-9][1-9]*\)\b/\1/g'
`
  fi
  if [ -z "$TARGET_VERSION" ]; then
    echo "Unable to determine target version to download for '$CMD' in repo '$REPO', this is a fatal bug. Please report it to the author."
    exit 1
  fi
  if [ `which $CMD` ]; then
    _version_toggle=${versions["$CMD"]}
    if [ -z "$_version_toggle" ]; then
      echo "Missing version command for '$CMD', this is a fatal bug. Please report it to the author."
      exit 1
    fi
    CURRENT_VERSION=`$CMD $_version_toggle | sed -n "s/^.*\(\([0-9]\+\.\)\{2\}[0-9]\+\).*$/\1/p"`
    if [ -z "$CURRENT_VERSION" ]; then
      echo "Unable to parse version output for '$CMD', this is a fatal bug. Please report it to the author."
      exit 1
    fi
    if [ "$CURRENT_VERSION" == "$TARGET_VERSION" ]; then
      ACTION=$ACTION_NOTHING
    else
      ACTION=$ACTION_UPDATE
    fi
  else
    CURRENT_VERSION='not installed'
    ACTION=$ACTION_INSTALL
  fi
  echo "local $CMD is $CURRENT_VERSION, target is $TARGET_VERSION => will $ACTION"
}

# downloads command $1 version $2 from repo $3 into dir $4
download() {
  _CMD=$1
  _VERSION=$2
  _REPO=$3
  _dir=$4
  filenamePattern=${releases["$_CMD"]}
  eval "_URL=$filenamePattern"
  echo "... download $_URL into $_dir"
  mkdir -p "$_dir"
  _CURL=`curl --fail -L $_URL -o $_dir/$_CMD.tmp`
  if [ $? -ne 0 ]; then
    echo "ERROR: unable to download specified version, please check that url is valid: $_URL"
#    rm $_dir/$_CMD.tmp
  else
    # all ok, we can replace existing
    chmod +x "$_dir/$_CMD.tmp"
    mv "$_dir/$_CMD.tmp" "$_dir/$_CMD"
  fi
}


# handle args

commands=("${_arg_commands[@]}")
# defaults to all installed commands
if [ ${#commands[@]} -eq 0 ]; then
  # loop through defined commands
  for cmd in "${!repos[@]}"; do
    which $cmd > /dev/null 2>&1 && commands+=($cmd)
  done
fi

for x in "${commands[@]}"
do
  command_to_up=${x%%=*}
  # this next line is needed to handle the case when we have only the app, no :tag.
  version_to_up=${x##$command_to_up}
  version_to_up=${version_to_up##*=}

  repo=${repos["$command_to_up"]}
  # if no repo, crash
  if [ -z "$repo" ]; then
    echo "Unable to determine repo to query for command '$command_to_up', are you sure this is a valid one?"
    exit 1
  fi

  # trigger update
  decide_action $command_to_up $repo $version_to_up

  case "$ACTION" in
    $ACTION_INSTALL)
#      dir=$_arg_dir
      # we manually replace leading ~ with $HOME, otherwise quoting wreaks havoc on the dirs
      # (as mkdir "~/dir" creates a subdir "~" in the current folder)
      dir="${_arg_dir/#~/$HOME}"
      if [ -z "$dir" ]; then
        echo "directory parameter is mandatory to install a new command, please re-run with --dir <install_dir>"
        exit 1
      fi
      # same here, substitute leading ~ to enable defensive quoting
      bin="${_arg_bin/#~/$HOME}"

#      echo "download $command_to_up $TARGET_VERSION $repo $dir"
#      exit 99

      download $command_to_up $TARGET_VERSION $repo $dir
      if [ -n "$bin" ]; then
        echo "... link to $bin/$command_to_up"
        mkdir -p $bin
        ln -sf "$dir"/$command_to_up "$bin"
      fi
      ;;
    $ACTION_UPDATE)
      full_cmd=`which $command_to_up`
      if [ -L "$full_cmd" ]; then
        dir=`dirname \`readlink $full_cmd\``
      else
        dir=`dirname $full_cmd`
      fi
      download $command_to_up $TARGET_VERSION $repo $dir
      ;;
  esac
done

# ] <-- needed because of Argbash
